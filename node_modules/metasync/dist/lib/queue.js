'use strict';

function Queue(concurrency // number, asynchronous concurrency
) {
  this.paused = false;
  this.concurrency = concurrency;
  this.waitTimeout = 0;
  this.processTimeout = 0;
  this.throttleCount = 0;
  this.throttleInterval = 1000;
  this.count = 0;
  this.tasks = [];
  this.waiting = [];
  this.factors = {};
  this.fifoMode = true;
  this.roundRobinMode = false;
  this.priorityMode = false;
  this.onProcess = null;
  this.onDone = null;
  this.onSuccess = null;
  this.onTimeout = null;
  this.onFailure = null;
  this.onDrain = null;
}

var QUEUE_TIMEOUT = 'Metasync: Queue timed out';

Queue.prototype.wait = function (
// Set wait before processing timeout
msec // number, wait timeout for single item
) {
  this.waitTimeout = msec;
  return this;
};

Queue.prototype.throttle = function (
// Throttle to limit throughput
count) // number (optional), per interval, default: 1000 msec
{
  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

  this.throttleCount = count;
  this.throttleInterval = interval;
  return this;
};

Queue.prototype.add = function (
// Add item to queue
item) // number (optional)
{
  var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  if (this.priorityMode && !this.roundRobinMode) {
    priority = factor;
    factor = 0;
  }
  var task = [item, factor, priority];
  var slot = this.count < this.concurrency;
  if (!this.paused && slot && this.onProcess) {
    this.next(task);
    return this;
  }
  var tasks = void 0;
  if (this.roundRobinMode) {
    tasks = this.factors[factor];
    if (!tasks) {
      tasks = [];
      this.factors[factor] = tasks;
      this.waiting.push(tasks);
    }
  } else {
    tasks = this.tasks;
  }

  if (this.fifoMode) tasks.push(task);else tasks.unshift(task);

  if (this.priorityMode) {
    if (this.fifoMode) {
      tasks.sort(function (a, b) {
        return b[2] - a[2];
      });
    } else {
      tasks.sort(function (a, b) {
        return a[2] - b[2];
      });
    }
  }
  return this;
};

Queue.prototype.next = function (
// Process next item
task // array, next task [item, factor, priority]
) {
  var _this = this;

  var item = task[0];
  var timer = void 0;
  this.count++;
  if (this.processTimeout) {
    timer = setTimeout(function () {
      var err = new Error(QUEUE_TIMEOUT);
      if (_this.onTimeout) _this.onTimeout(err);
    }, this.processTimeout);
  }
  this.onProcess(item, function (err, result) {
    if (_this.onDone) _this.onDone(err, result);
    if (err) {
      if (_this.onFailure) _this.onFailure(err);
    } else if (_this.onSuccess) {
      _this.onSuccess(result);
    }
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    _this.count--;
    if (_this.tasks.length > 0 || _this.waiting.length > 0) {
      _this.takeNext();
    } else if (_this.count === 0 && _this.onDrain) {
      _this.onDrain();
    }
  });
  return this;
};

Queue.prototype.takeNext = function ()
// Prepare next item for processing
{
  if (this.paused || !this.onProcess) {
    return this;
  }
  var tasks = void 0;
  if (this.roundRobinMode) {
    tasks = this.waiting.shift();
    if (tasks.length > 1) {
      this.waiting.push(tasks);
    }
  } else {
    tasks = this.tasks;
  }
  var task = tasks.shift();
  if (task) this.next(task);
  return this;
};

Queue.prototype.pause = function ()
// Pause queue
{
  this.paused = true;
  // stub
  return this;
};

Queue.prototype.resume = function ()
// Resume queue
{
  this.paused = false;
  // stub
  return this;
};

Queue.prototype.clear = function ()
// Clear queue
{
  this.count = 0;
  this.tasks = [];
  this.waiting = [];
  this.factors = {};
  return this;
};

Queue.prototype.timeout = function (
// Set timeout interval and listener
msec) // function, (item) => {}
{
  var onTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  this.processTimeout = msec;
  if (onTimeout) this.onTimeout = onTimeout;
  return this;
};

Queue.prototype.process = function (
// Set processing function
fn // function, processing (item, callback)
) {
  this.onProcess = fn;
  return this;
};

Queue.prototype.done = function (
// Set listener on processing done
fn // function, done listener (err, result)
) {
  this.onDone = fn;
  return this;
};

Queue.prototype.success = function (
// Set listener on processing success
listener // function, on success (item) => {}
) {
  this.onSuccess = listener;
  return this;
};

Queue.prototype.failure = function (
// Set listener on processing error
listener // function, on failure (err, item) => {}
) {
  this.onFailure = listener;
  return this;
};

Queue.prototype.drain = function (
// Set listener on drain Queue
listener // function, on drain () => {}
) {
  this.onDrain = listener;
  return this;
};

Queue.prototype.fifo = function ()
// Switch FIFO mode (default for Queue)
{
  this.fifoMode = true;
  return this;
};

Queue.prototype.lifo = function ()
// Switch LIFO mode
{
  this.fifoMode = false;
  return this;
};

Queue.prototype.priority = function () // boolean, default: true, use false to disable priority mode
{
  var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  this.priorityMode = flag;
  return this;
};

Queue.prototype.roundRobin = function () // boolean, default: true, use false to disable roundRobin mode
{
  var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  this.roundRobinMode = flag;
  return this;
};

Queue.prototype.pipe = function (
// Pipe processed items to different queue
dest // Queue, destination queue
) {
  if (dest instanceof Queue) {
    this.success(function (item) {
      dest.add(item);
    });
  }
  return this;
};

// Queue instantiation
//   concurrency - number, of simultaneous and asynchronously executing tasks
// Returns: Queue, instance
var queue = function queue(concurrency) {
  return new Queue(concurrency);
};

module.exports = { queue: queue };