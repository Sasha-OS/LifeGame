'use strict';

var common = require('@metarhia/common');

var map = function map(
// Asynchronous map (iterate parallel)
items, // array, incoming
fn, // function, (current, callback) => callback(err, value)
//   to be executed for each value in the array
//   current - current element being processed in the array
//   callback - function(err, value)
done // function (optional), on done callback function(err, result)
) {
  done = done || common.emptyness;
  var len = items.length;
  if (!len) {
    done(null, []);
    return;
  }
  var errored = false;
  var count = 0;
  var result = new Array(len);

  var next = function next(index, err, value) {
    if (errored) return;
    if (err) {
      errored = true;
      done(err);
      return;
    }
    result[index] = value;
    count++;
    if (count === len) done(null, result);
  };

  for (var i = 0; i < len; i++) {
    fn(items[i], next.bind(null, i));
  }
};

var filter = function filter(
// Asynchrous filter (iterate parallel)
items, // array, incoming
fn, // function, (value, callback) => (err, accepted)
//    to be executed for each value in the array
//    value - item from items array
//    callback - function(err, accepted)
done // optional on done callback function(err, result)
) {
  done = done || common.emptyness;
  var len = items.length;

  if (!len) {
    done(null, []);
    return;
  }

  var count = 0;
  var suitable = 0;
  var data = new Array(len);
  var rejected = Symbol('rejected');

  var next = function next(index, err, accepted) {
    if (!accepted || err) {
      data[index] = rejected;
    } else {
      data[index] = items[index];
      suitable++;
    }
    count++;
    if (count === len) {
      var result = new Array(suitable);
      var pos = 0;
      for (var i = 0; i < len; i++) {
        var val = data[i];
        if (val !== rejected) result[pos++] = val;
      }
      done(null, result);
    }
  };

  for (var i = 0; i < len; i++) {
    fn(items[i], next.bind(null, i));
  }
};

var EMPTY_ARR = 'Metasync: reduce of empty array with no initial value';

var reduce = function reduce(
// Asynchronous reduce
items, // array, incoming
fn, // function, to be executed for each value in array
//   previous - value previously returned in the last iteration
//   current - current element being processed in the array
//   callback - callback for returning value back to function reduce
//   counter - index of the current element being processed in array
//   items - the array reduce was called upon
done, // function (optional), on done callback function(err, result)
initial // optional value to be used as first arpument in first iteration
) {
  done = done || common.emptyness;
  var len = items.length;
  var count = typeof initial === 'undefined' ? 1 : 0;

  if (!len) {
    var err = count ? new TypeError(EMPTY_ARR) : null;
    done(err, initial);
    return;
  }

  var previous = count === 1 ? items[0] : initial;
  var current = items[count];
  var last = len - 1;

  var next = function next(err, data) {
    if (err) {
      done(err);
      return;
    }
    if (count === last) {
      done(null, data);
      return;
    }
    count++;
    previous = data;
    current = items[count];
    fn(previous, current, next, count, items);
  };

  fn(previous, current, next, count, items);
};

var each = function each(
// Asynchronous each (iterate in parallel)
items, // array, incoming
fn, // function, (value, callback) => callback(err)
//   value - item from items array
//   callback - callback function(err)
done // function (optional), on done callback function(err, items)
) {
  done = done || common.emptyness;
  var len = items.length;
  if (len === 0) {
    done(null, items);
    return;
  }
  var count = 0;
  var errored = false;

  var next = function next(err) {
    if (errored) return;
    if (err) {
      errored = true;
      done(err);
      return;
    }
    count++;
    if (count === len) done(null);
  };

  for (var i = 0; i < len; i++) {
    fn(items[i], next);
  }
};

var series = function series(
// Asynchronous series
items, // array, incoming
fn, // function, (value, callback) => callback(err)
//   value - item from items array
//   callback - callback (err)
done // function (optional), on done callback (err, items)
) {
  done = done || common.emptyness;
  var len = items.length;
  var i = -1;

  var next = function next() {
    i++;
    if (i === len) {
      done(null, items);
      return;
    }
    fn(items[i], function (err) {
      if (err) {
        done(err);
        return;
      }
      setImmediate(next);
    });
  };
  next();
};

var find = function find(
// Asynchronous find (iterate in series)
items, // array, incoming
fn, // (value, callback) => callback(err, accepted)
//   value - item from items array
//   callback - callback function(err, accepted)
done // function (optional), on done callback function(err, result)
) {
  done = done || common.emptyness;
  var len = items.length;
  if (len === 0) {
    done();
    return;
  }
  var finished = false;
  var last = len - 1;

  var next = function next(index, err, accepted) {
    if (finished) return;
    if (err) {
      finished = true;
      done(err);
      return;
    }
    if (accepted) {
      finished = true;
      done(null, items[index]);
      return;
    }
    if (index === last) done(null);
  };

  for (var i = 0; i < len; i++) {
    fn(items[i], next.bind(null, i));
  }
};

var every = function every(
// Asynchronous every
items, // array, incoming
fn, // function, (value, callback) => callback(err, fits)
//   value - item from items array
//   callback - callback function(err, fits)
done // function, optional on done callback function(err, result)
) {
  done = done || common.emptyness;
  if (items.length === 0) {
    done(null, true);
    return;
  }
  var proceedItemsCount = 0;
  var len = items.length;

  var finish = function finish(err, accepted) {
    if (!done) return;
    if (err || !accepted) {
      done(err, false);
      done = null;
      return;
    }
    proceedItemsCount++;
    if (proceedItemsCount === len) done(null, true);
  };

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;
      fn(item, finish);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

var some = function some(
// Asynchronous some (iterate in series)
items, // array, incoming
fn, // function, (value, callback) => (err, accepted)
//   value - item from items array
//   callback - callback function(err, accepted)
done // function, on done callback function(err, result)
) {
  done = done || common.emptyness;
  var len = items.length;
  var i = 0;

  var next = function next() {
    if (i === len) {
      done(null, false);
      return;
    }
    fn(items[i], function (err, accepted) {
      if (err) {
        done(err);
        return;
      }
      if (accepted) {
        done(null, true);
        return;
      }
      i++;
      next();
    });
  };

  if (len > 0) next();else done(null, false);
};

module.exports = {
  map: map,
  filter: filter,
  reduce: reduce,
  each: each,
  series: series,
  find: find,
  every: every,
  some: some
};