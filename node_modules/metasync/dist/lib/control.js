'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var common = require('@metarhia/common');

var _require = require('./array'),
    each = _require.each;

var firstOf = function firstOf(
// Executes all asynchronous functions and pass first result to callback
fns, // array of function, callback-last / err-first
callback // function, err-first on done
) {
  var done = common.once(callback);
  each(fns, function (f, iterCb) {
    return f(function () {
      done.apply(undefined, arguments);
      iterCb.apply(undefined, arguments);
    });
  });
};

var parallel = function parallel(
// Parallel execution
fns, // array of function, callback-last / err-first
context, // incoming data (optional)
callback // function, err-first on done
) {
  if (!callback) {
    callback = context;
    context = {};
  }
  var done = common.once(callback);
  var isArray = Array.isArray(context);
  var len = fns.length;
  if (len === 0) {
    done(null, context);
    return;
  }
  var counter = 0;

  var finishFn = function finishFn(fn, err, result) {
    if (err) {
      done(err);
      return;
    }
    if (result !== context && result !== undefined) {
      if (isArray) context.push(result);else if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') Object.assign(context, result);
    }
    if (++counter === len) done(null, context);
  };

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = fns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fn = _step.value;

      // fn may be array of function
      var finish = finishFn.bind(null, fn);
      if (fn.length === 2) fn(context, finish);else fn(finish);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

var sequential = function sequential(
// Sequential execution
fns, // array of callback-last functions, callback contranct err-first
context, // incoming data (optional)
callback // function, err-first on done
) {
  if (!callback) {
    callback = context;
    context = {};
  }
  var done = common.once(callback);
  var isArray = Array.isArray(context);
  var len = fns.length;
  if (len === 0) {
    done(null, context);
    return;
  }
  var i = -1;

  var next = function next() {
    var fn = null;
    var finish = function finish(err, result) {
      if (result !== context && result !== undefined) {
        if (isArray) context.push(result);else if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') Object.assign(context, result);
      }
      if (err) {
        done(err);
        return;
      }
      next();
    };
    if (++i === len) {
      done(null, context);
      return;
    }
    fn = fns[i];
    if (fn.length === 2) fn(context, finish);else fn(finish);
  };

  next();
};

module.exports = {
  firstOf: firstOf,
  parallel: parallel,
  sequential: sequential
};