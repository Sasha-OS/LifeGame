'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var _require = require('./array'),
    map = _require.map,
    filter = _require.filter,
    reduce = _require.reduce,
    each = _require.each,
    series = _require.series,
    find = _require.find;

var async = function async(op) {
  switch (op) {
    case 'map':
      return map;
    case 'filter':
      return filter;
    case 'reduce':
      return reduce;
    case 'each':
      return each;
    case 'series':
      return series;
    case 'find':
      return find;
  }
  return function (items, fn, callback) {
    callback(null, items.slice());
  };
};

function ArrayChain(array) {
  this.array = array;
  this.chain = [];
}

ArrayChain.prototype.execute = function (err) {
  var _this = this;

  var item = this.chain.shift() || {};

  if (!item.op) {
    if (err) throw err;else return null;
  }

  var next = function next(err, data) {
    _this.array = data;
    _this.execute(err);
  };

  if (item.op === 'fetch') {
    return item.fn(err, this.array, next);
  }

  if (err) {
    this.execute(err);
    return null;
  }

  if (item.isSync) {
    this.array = item.fn();
    this.execute(null);
  } else {
    var op = async(item.op);
    op(this.array, item.fn, next);
  }

  return null;
};

ArrayChain.prototype.fetch = function (fn) {
  this.chain.push({ op: 'fetch', fn: fn });
  this.execute();
  return this;
};

ArrayChain.prototype.map = function (fn) {
  this.chain.push({ op: 'map', fn: fn });
  return this;
};

ArrayChain.prototype.filter = function (fn) {
  this.chain.push({ op: 'filter', fn: fn });
  return this;
};

ArrayChain.prototype.reduce = function (fn) {
  this.chain.push({ op: 'reduce', fn: fn });
  return this;
};

ArrayChain.prototype.each = function (fn) {
  this.chain.push({ op: 'each', fn: fn });
  return this;
};

ArrayChain.prototype.series = function (fn) {
  this.chain.push({ op: 'series', fn: fn });
  return this;
};

ArrayChain.prototype.find = function (fn) {
  this.chain.push({ op: 'find', fn: fn });
  return this;
};

var syncDelegates = {
  returns: {
    opNames: ['concat', 'slice', 'includes'],
    handler: function handler(op) {
      var _array;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_array = this.array)[op].apply(_array, _toConsumableArray(args));
    }
  },
  modify: {
    opNames: ['reverse', 'sort', 'shift', 'unshift', 'push', 'pop'],
    handler: function handler(op) {
      var _array2;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (_array2 = this.array)[op].apply(_array2, _toConsumableArray(args));
      return this.array;
    }
  }
};

var _loop = function _loop(delegateType) {
  var _syncDelegates$delega = syncDelegates[delegateType],
      opNames = _syncDelegates$delega.opNames,
      handler = _syncDelegates$delega.handler;

  var _loop2 = function _loop2(op) {
    ArrayChain.prototype[op] = function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var fn = handler.bind.apply(handler, [this, op].concat(args));
      this.chain.push({ op: op, fn: fn, isSync: true });
      return this;
    };
  };

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = opNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var op = _step.value;

      _loop2(op);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

for (var delegateType in syncDelegates) {
  _loop(delegateType);
}

// Create an ArrayChain instance
//   array - array, start mutations from this data
// Returns: ArrayChain instance
var forArrayChain = function forArrayChain(array) {
  return new ArrayChain(array);
};

module.exports = { for: forArrayChain };